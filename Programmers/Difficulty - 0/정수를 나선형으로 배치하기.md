# 정수를 나선형으로 배치하기

Difficulty: 0
Last Updated: 2023년 5월 9일 오후 3:07
Resolved: true

링크 - [정수를 나선형으로 배치하기](https://school.programmers.co.kr/learn/courses/30/lessons/181832)

**문제 설명**

양의 정수 `n`이 매개변수로 주어집니다. `n` × `n` 배열에 1부터 `n`2 까지 정수를 인덱스 [0][0]부터 시계방향 나선형으로 배치한 이차원 배열을 return 하는 solution 함수를 작성해 주세요.

**제한사항**

- • 1 ≤ `n` ≤ 30

**입출력 예**

| n | result |
| --- | --- |
| 4 | [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] |
| 5 | [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]] |

**입출력 설명 #1**

- 예제 1번의 `n`의 값은 4로 4 × 4 배열에 다음과 같이 1부터 16까지 숫자를 채울 수 있습니다.
    
    
    | 행 \ 열 | 0 | 1 | 2 | 3 |
    | --- | --- | --- | --- | --- |
    | 0 | 1 | 2 | 3 | 4 |
    | 1 | 12 | 13 | 14 | 5 |
    | 2 | 11 | 16 | 15 | 6 |
    | 3 | 10 | 9 | 8 | 7 |
    
    따라서 [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]를 return 합니다.
    

**입출력 설명 #2**

- 예제 2번의 `n`의 값은 5로 5 × 5 배열에 다음과 같이 1부터 25까지 숫자를 채울 수 있습니다.
    
    
    | 행 \ 열 | 0 | 1 | 2 | 3 | 4 |
    | --- | --- | --- | --- | --- | --- |
    | 0 | 1 | 2 | 3 | 4 | 5 |
    | 1 | 16 | 17 | 18 | 19 | 6 |
    | 2 | 15 | 24 | 25 | 20 | 7 |
    | 3 | 14 | 23 | 22 | 21 | 8 |
    | 4 | 13 | 12 | 11 | 10 | 9 |
    
    따라서 [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]를 return 합니다.
    

**풀이**

```kotlin
class Solution {
    private var direction = 1

    fun solution(n: Int): Array<IntArray> {
        val list = MutableList(n) { MutableList(n) { 0 } }
        var point = mutableListOf(0, -1)
        var prePoint = mutableListOf<Int>()
        var num = 1
        
        while (num <= n * n) {
            try {
                prePoint = mutableListOf(point.first(), point.last())
                when(direction) {
                    1 -> { point[1]++ }
                    2 -> { point[0]++ }
                    3 -> { point[1]-- }
                    4 -> { point[0]-- }
                }
                if (list[point.first()][point.last()] != 0) { point = prePoint; change(); continue }
                else { list[point.first()][point.last()] = num; num++ }
            } catch (_: Exception) {
                point = prePoint
                change()
            }
        }
        return list.map { it.toIntArray() }.toTypedArray()
    }

    private fun change() {
        if (direction == 4) direction = 1 else direction++
    }
}
```